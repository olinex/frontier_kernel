/* set archtecture as riscv */
OUTPUT_ARCH(riscv)

/* set entry point as symbol '_fn_start' which was defined in src/assembly/entry.asm */
ENTRY(_fn_start)

/* memory.ld will be generated by Makefile, will was choiced according to platform("sbi" and "board") */
INCLUDE memory.ld

SECTIONS
{
    /* declare kernel start address */
    PROVIDE(_addr_kernel_start = .);

    /*  the first section was code text */
    /* declare the .text section distribution */
    .text : {
        PROVIDE(_addr_text_start = .);
        /* sub sction .text.entry will be the first part of .text section */
        *(.text.entry)
        *(.text .text.*)
        PROVIDE(_addr_text_end = .);
    } > RAM

    /* declare inited read only data section */
    .rodata : {
        PROVIDE(_addr_rodata_start = .);
        *(.rodata .rodata.*)
        PROVIDE(_addr_rodata_end = .);
    } > RAM

    /* declare inited read write data section */
    .data : {
        PROVIDE(_addr_data_start = .);
        *(.data .data.*)
        PROVIDE(_addr_data_end = .);
    } > RAM

    /* declare uninit data section */
    .bss : {
        PROVIDE(_addr_bss_start = .);
        *(.bss .bss.*)
        /* sub section .bss.bootstack was defined in src/assemble/entry.asm  */
        *(.bss.bootstack)
        PROVIDE(_addr_bss_end = .);
    } > RAM
    /* ======== bss ======== */

    PROVIDE(_addr_kernel_end = .);
    PROVIDE(_addr_memory_start = ORIGIN(RAM));
    PROVIDE(_addr_memory_end = _addr_memory_start + LENGTH(RAM));
    PROVIDE(_addr_heap_start = _addr_kernel_end);
    PROVIDE(_size_heap = _addr_memory_end - _addr_kernel_end);
    /DISCARD/ : {
        *(.eh_frame)
    }
}